import os
import logging
from flask import Flask, request, jsonify, abort
import google.generativeai as genai

# --- Configuration ---

# 1. API Key (Recommended: Use Environment Variable)
GOOGLE_API_KEY = "AIzaSyAdubNkNMtRoQILIQAqOXIg59FZFxBaLnM"

# 2. Model Name (Verify availability in Google AI documentation)
#    'gemini-1.5-flash-latest' is often available via the SDK.
MODEL_NAME = os.environ.get("GEMINI_MODEL_NAME", 'gemini-1.5-flash-latest')

# --- Essential Checks ---
if not GOOGLE_API_KEY:
    # Use print for errors before logger might be configured
    print("ðŸ”´ FATAL ERROR: GOOGLE_API_KEY environment variable is not set.")
    exit(1) # Exit if the key is missing

# --- Configure Gemini ---
try:
    genai.configure(api_key=GOOGLE_API_KEY)
except Exception as e:
    print(f"ðŸ”´ FATAL ERROR: Failed to configure Google Generative AI: {e}")
    exit(1)

# --- Initialize Model (Do this once at startup) ---
try:
    print(f"[*] Initializing Gemini model: {MODEL_NAME}...")
    model = genai.GenerativeModel(MODEL_NAME)
    print("[+] Model initialized successfully.")
except Exception as e:
    print(f"ðŸ”´ FATAL ERROR: Failed to initialize Gemini model ({MODEL_NAME}): {e}")
    exit(1)


# --- Flask Application ---
app = Flask(__name__)

# Configure Flask logging (optional but good practice)
logging.basicConfig(level=logging.INFO) # Log informational messages and above


@app.route('/generate', methods=['POST'])
def generate_text():
    """
    Receives a text prompt via JSON POST request and returns text
    generated by the configured Gemini model.
    """
    # Check if the request content type is JSON
    if not request.is_json:
        app.logger.warning("Received non-JSON request")
        # Use Flask's abort to trigger the 400 error handler
        abort(400, description="Bad Request: Request body must be JSON.")

    # Get JSON data from the request
    data = request.get_json()

    # Validate input data
    if not data or 'prompt' not in data or not isinstance(data['prompt'], str) or not data['prompt'].strip():
        app.logger.warning(f"Received invalid request data: {data}")
        abort(400, description="Bad Request: Missing or invalid 'prompt' (must be a non-empty string) in request body.")

    prompt = data['prompt'].strip()
    # Log only the beginning of potentially long prompts
    app.logger.info(f"Received prompt (first 50 chars): '{prompt[:50]}...'")

    try:
        # Call the Gemini API using the pre-initialized model
        app.logger.info(f"[*] Calling Gemini API ({MODEL_NAME})...")
        response = model.generate_content(prompt)

        # Handle potential safety blocks or lack of content
        if not response.parts:
             app.logger.warning(f"Gemini API returned no parts. Feedback: {response.prompt_feedback}")
             # Check for specific block reasons if available
             block_reason = getattr(response.prompt_feedback, 'block_reason', None)
             if block_reason:
                 abort(400, description=f"Content generation blocked by API: {block_reason}")
             else:
                 abort(500, description="API returned an empty response without a specific block reason.")

        generated_text = response.text # Access text via .text attribute
        app.logger.info(f"[+] Successfully generated content from Gemini.")
        # Use jsonify to create a JSON response
        return jsonify(generated_text=generated_text)

    except Exception as e:
        # Log the full error server-side
        app.logger.error(f"Error during Gemini API call: {e}", exc_info=True) # exc_info=True logs stack trace
        # Return a generic error to the client
        error_detail = f"An error occurred while communicating with the Gemini API."
        # Use the 500 error handler
        abort(500, description=error_detail)


# --- Error Handlers (Customize JSON error responses) ---
@app.errorhandler(400)
def bad_request(error):
    """Handles 400 Bad Request errors triggered by abort(400, ...)."""
    response = jsonify(error=str(error.description))
    response.status_code = 400
    return response

@app.errorhandler(500)
def internal_server_error(error):
    """Handles 500 Internal Server Error triggered by abort(500, ...) or unhandled exceptions."""
    # Log the original error if it's available (might not be if abort was used directly)
    # if hasattr(error, 'original_exception'):
    #    app.logger.error(f"Original exception: {error.original_exception}", exc_info=True)
    response = jsonify(error=str(error.description) if error.description else "Internal Server Error")
    response.status_code = 500
    return response

# @app.errorhandler(503) # Less common unless specifically triggered
# def service_unavailable(error):
#     response = jsonify(error=str(error.description))
#     response.status_code = 503
#     return response

# --- Root endpoint for health check ---
@app.route('/')
def health_check():
    """Basic health check endpoint."""
    return jsonify(status=f"API is running, using model: {MODEL_NAME}")

# --- Main Execution ---
if __name__ == '__main__':
    # Get host and port from environment variables or use defaults
    host = os.environ.get("FLASK_HOST", "127.0.0.1") # Default to localhost
    port = int(os.environ.get("FLASK_PORT", 5000))  # Default to port 5000
    debug_mode = os.environ.get("FLASK_DEBUG", "False").lower() == "true" # Enable debug if FLASK_DEBUG=true

    print(f"[*] Starting Flask server on http://{host}:{port}")
    if debug_mode:
        print("[!] Running in DEBUG mode. Do NOT use in production.")

    # Run the Flask development server
    # Use host='0.0.0.0' to make it accessible from other devices on your network
    # Set debug=False for production environments
    app.run(host=host, port=port, debug=debug_mode)